;
; This file strips all symbols from sections of an ELF file generated by a HighTec compiler
; belonging to specific CPUs.
; Option /VERBOSE will enable printing of deleted sections.
;
; Usage:
;    DO <path to file>\stripCPUSections.cmm <list of CPUs> [/VERBOSE]
;
; Example:
;    DO <path to file>\stripCPUSections.cmm CPU0 CPU2     deletes symbol information for CPU0 and CPU2
;

; declare local variables
LOCAL &cpuList &bVerbose
ENTRY %line &cpuList

&bVerbose=FALSE()
IF (STRing.SCAN("&cpuList","/VERBOSE",0)!=-1)
(
    &bVerbose=TRUE()
    &cpuList=STRing.REPLACE("&cpuList","/VERBOSE","",0)
)

GOSUB ForEachSection GOSUB ProcessSection

ENDDO

; procedure ProcessSection
; Delete a section given by name if it belongs to one of the CPUs listend in &cpuList
; parameters:
;     sectionName  String   the name of the section
;     secAccess    String   access class associated with this section
;     secStart     int      begin of the section's address range
;     secEnd       int      end of the section's address range
ProcessSection:
(
    PRIVATE &sectionName &secStart &secEnd &dot1 &dot2 &cpu
    PRIVATE &secStartGlob &secEndGlob &secAccess &secGlobBase &addrRange
    ENTRY &sectionName &secAccess &secStart &secEnd
    &sectionName=&sectionName

    ; check if this section belongs to one of the CPUs of interest
    &dot1=STRing.SCAN("&sectionName",".",0)
    IF (&dot1==-1)                                 ; invalid line
        RETURN
    &dot2=STRing.SCAN("&sectionName",".",&dot1+1)
    IF (&dot2==-1)                                 ; only one dot in this line -> no CPU specific section
        RETURN
    &cpu=STRing.MID("&sectionName",&dot1+1,&dot2-&dot1-1)
    IF (STRing.SCAN("&cpuList","&cpu",0)==-1)      ; test if not in list
        RETURN

    &secGlobBase=-1
    &secLocalBase=-1

    ; translate local to global addresses
    IF ((0xC0000000<=&secStart)&&(&secStart<=0xCFFFFFFF))
    (
        &secLocalBase=0xC0000000
        IF ("&cpu"=="CPU0")
            &secGlobBase=0x70100000
        ELSE IF ("&cpu"=="CPU1")
            &secGlobBase=0x60100000
        ELSE IF ("&cpu"=="CPU2")
            &secGlobBase=0x50100000
    )
    ELSE IF ((0xD0000000<=&secStart)&&(&secStart<=0xDFFFFFFF))
    (
        &secLocalBase=0xD0000000
        IF ("&cpu"=="CPU0")
            &secGlobBase=0x70000000
        ELSE IF ("&cpu"=="CPU1")
            &secGlobBase=0x60000000
        ELSE IF ("&cpu"=="CPU2")
            &secGlobBase=0x50000000
    )
    IF (&secGlobBase!=-1)
    (
        &secStartGlob=&secStart-(&secLocalBase-&secGlobBase)
        &secEndGlob=&secEnd-(&secLocalBase-&secGlobBase)
        sYmbol.Delete &secAccess:&secStartGlob--&secEndGlob
    )

    sYmbol.Delete &secAccess:&secStart--&secEnd
    IF &bVerbose
    (
        PRINT "Deleted: &sectionName"
    )
    RETURN
)

;--------------------------------------------------------------------------------
; helper procedures

; procedure ForEachSection
; executes a given PRACTICE command for each section
; in the command the following place holders might be used
;   %secname%    name of the section
; parameters:
;     command string    the command to execute
ForEachSection:
(
    PRIVATE &data &secFile &line &cmd &cmdLocal
    PRIVATE &secRange &secName &remainder

    ; Read command line parameters
    ENTRY %line &cmd


    ; Define name of temporary file
    &secFile=OS.TMPFILE()+".lst"

    ; Write content of sYmbol.List.SECtion window to temporary file
    ; Set maximum sizes for variable columns
    WinTABS 128. 3. 16.
    PRinTer.EXPORT &secFile
    WinPrint.sYmbol.List.SECtion

    ; Open temporary file
    OPEN #1 &secFile /Read

    ; Discard first two lines (header)
    READ #1 %line &line
    READ #1 %line &line

    ; read list of sections
    WHILE !EOF()
    (
        READ #1 %line &line
        ; implicitly split lines at comma by calling ForEachLine

        GOSUB SplitLine &line
        ENTRY &secRange &secName %line &remainder

        &secRange=&secRange

        ; Prepare command
        &secRange=STRing.REPLACE("&secRange",":"," 0x",0)
        &secRange=STRing.REPLACE("&secRange","--"," 0x",0)

        &cmd &secName &secRange
    )

    ; close temporary file
    CLOSE #1
    RM &secFile

    RETURN
)

; Split a comma seperated line into single entries
; parameters:
;    line String          the line to split
; returns:
;    c0 ... cN  String    the single columns of the line
SplitLine:
(
    PRIVATE &line
    ENTRY %line &line
    &line=STRing.REPLACE("&line",""",""",""" """,0)    ; replace commas by white space
    RETURN &line                                       ; let the PRACTICE parser do the work
)
